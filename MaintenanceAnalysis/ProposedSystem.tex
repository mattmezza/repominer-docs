\chapter{Sistema proposto}
\section{Requisiti funzionali}\label{req_fun}
Il sistema dovrà essere in grado di calcolare metriche relative all'entropia di un progetto software.

Più in particolare, dovrà essere possibile calcolare le seguenti metriche basilari:
\begin{itemize}
\item Numero di revisioni del sistema;
\item Numero medio di volte in cui i file di un package hanno subito
cambiamenti;
\item Numero medio di volte in cui i file di un package hanno subito operazioni
di refactoring;
\item Numero medio di volte in cui i file di un package hanno subito operazioni di
bug fixing;
\item Numero di autori di commit effettuati all’interno di un package;
\item Numero di linee aggiunte o rimosse (somma, media e massimo);
\item Dimensione media dei file modificati.
\end{itemize}

Il sistema dovrà implementare il Basic Code Change Model descritto nell'articolo di Hassan \cite{hassan2009predicting}.
In primo luogo, dovranno essere estratti i cambiamenti dovuti ad aggiunte di feature: per fare ciò si analizzeranno i messaggi di commit (non dovranno contenere parole che denotano altri tipi di cambiamenti, come, ad esempio: "bug-fix", "re-indent", "copyright update", etc.).

Dovranno essere implementate, quindi, le seguenti metriche:
\begin{itemize}
\item Numero di cambiamenti totali di ogni file (righe aggiunte + righe cancellate) di un dato progetto software a seguito di aggiunta di feature in un periodo di riferimento (es: un mese)
\item Entropia dei cambiamenti dei file del progetto nel periodo fissato
\end{itemize}

Il sistema dovrà implementare l'Extended Code Change Model descritto nell'articolo di Hassan \cite{hassan2009predicting}; l'utente dovrà poter scegliere la tipologia di suddivisione del sistema nel tempo tra:
\begin{itemize}
\item \textbf{Periodi fissati}: i cambiamenti del sistema sono divisi in periodi di tempo prestabiliti (es:un mese), come nel BCC
\item \textbf{Numero di cambiamenti fissati}: si usa un numero prefissato di cambiamenti per stabilire i differenti periodi da analizzare
\item \textbf{Periodi di burst}: si distinguono i periodi in base alle "raffiche" di cambiamenti che occorrono
\end{itemize}
Inoltre, il sistema calcolerà, al posto dell'entropia classica, l'Adapting Sizing Entropy, ovvero l'entropia normalizzata in base al numero di file modificati nell'ultimo periodo (che dovrà essere definito dall'utente, e potrà essere \emph{temporale} o basato sul \emph{numero di modifiche}).